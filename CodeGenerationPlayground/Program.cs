using CodeGeneration;
using CodeGeneration.Builders;
using CodeGenerationPlayground.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Emit;
using System.Reflection;

internal class Program
{
    private static void Main(string[] args)
    {
        var commonTokenBuilder = new CommonTokenBuilder();
        var method = new MethodBuilder(commonTokenBuilder)
            .SetIdentifier("TestMethod1")
            .AddModifier(Modifier.Public)
            .AddModifier(Modifier.Static)
            .AddMethodParameter(
                new ParameterBuilder(commonTokenBuilder)
                .SetType("string")
                .SetIdentifier("param1")
            )
            .SetReturnType(new TypeBuilder().SetType<string>())
            .SetBody<BodyBuilder>( builder  =>
                builder.AddStatements(
                    new List<StatementSyntax>
                    {
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.IdentifierName("param1")
                        )
                    }
                )
            )
            .Build();

        new BodyBuilder();

        var methodFromBuilder = new MethodBuilder(commonTokenBuilder)
            .SetIdentifier("TestMethod")
            .SetReturnType(new TypeBuilder().SetType<int>())
            .AddModifier(Modifier.Static)
            .AddMethodParameter(
                new ParameterBuilder(commonTokenBuilder)
                .SetIdentifier("autoGenParamater1")
                .SetType("string")
            )
            .SetBody<BodyBuilder>( builder => 
                builder.AddStatements(new List<StatementSyntax>() {
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.LiteralExpression(
                            SyntaxKind.NumericLiteralExpression,
                            SyntaxFactory.Literal(1)
                        )
                    )
                })
            )
            .Build();

        var testClass = new ClassBuilder(commonTokenBuilder)
            .SetIdentifier("AutogenClass")
            .AddModifier(Modifier.Public)
            .AddMembers(
                new List<MemberDeclarationSyntax>
                {
            method,
            methodFromBuilder
                }
            )
            .AddMembers(
                new List<ISyntaxBuilder<MemberDeclarationSyntax>>
                {
            new MethodBuilder(commonTokenBuilder)
                .SetIdentifier("MethodFromBuilder")
                .SetReturnType(new TypeBuilder().SetType(typeof(void)))
                .SetBody<BodyBuilder>(builder =>
                {
                })
                .AddModifier(Modifier.Private),
                }
            )
            .Build();

        var defaultNamespace = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName("AutogeneratedNamespace"));
        defaultNamespace = defaultNamespace.AddMembers(testClass);


        var unit = SyntaxFactory.CompilationUnit();
        unit = unit
            .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("System")))
            .AddMembers(defaultNamespace);

        Console.WriteLine("Analysis of AutoGeneratedCode");
        Console.WriteLine(unit.NormalizeWhitespace().ToFullString());

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine();

        var systemRefLocation = typeof(object).GetTypeInfo().Assembly.Location;
        var systemReference = MetadataReference.CreateFromFile(systemRefLocation);

        Console.WriteLine("Compiling...");

        var filename = "autogen1.dll";
        var compilation = CSharpCompilation.Create(filename)
            .WithOptions(new(OutputKind.DynamicallyLinkedLibrary))
            .AddReferences(systemReference)
            .AddSyntaxTrees(unit.SyntaxTree);

        string path = Path.Combine(Directory.GetCurrentDirectory(), filename);

        EmitResult compilationResult = compilation.Emit(path);
        if (compilationResult.Success)
        {
            Console.WriteLine("Compiled Success");

            Assembly asm = System.Runtime.Loader.AssemblyLoadContext.Default.LoadFromAssemblyPath(path);
            Type? testType = asm.GetType("AutogeneratedNamespace.AutogenClass");
            MethodInfo? testMethod = testType?.GetMethod("TestMethod1");

            if (testMethod?.IsGenericMethod == true)
            {
                testMethod = testMethod.MakeGenericMethod(typeof(string));
            }

            object? result = testMethod?.Invoke(null, new[] { "test" });
            Console.WriteLine($"{result as string}");
        }
        else
        {
            Console.WriteLine("Compilation Failed");
            DiagnosticHelper.PrintDiagnostics(compilationResult.Diagnostics);
        }

        Console.ReadLine();
    }
}